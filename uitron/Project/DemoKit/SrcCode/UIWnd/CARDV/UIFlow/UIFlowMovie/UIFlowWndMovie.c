//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "Audio.h"
#include "md_api.h"
#include "FileSysTsk.h"
#include  "rtc.h"
//#include "ImageApp_Movie.h"
#include "MovieInterface.h"
#include "ImageApp_MovieMulti.h"
#include "ImageApp_Photo.h" //for NVTEVT_CALLBACK, NVTEVT_CB_ZOOM, NVTEVT_ALGMSG_PREVIEW_STABLE
#if (CALIBRATION_FUNC == ENABLE)
#include "EngineerMode.h"
#endif

#if USE_FILEDB
#include "FileDB.h"
#include "NameRule_FileDB.h"
#endif
#include "UIFlow.h"
#include "GSensor.h"
#include "display.h"
//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
#if MOVIE_OT_FUNC
#include "NvtOt.h"
#endif
//#NT#2016/05/23#David Tsai -begin
//#NT# Support tampering detection function
#if MOVIE_BC_FUNC || MOVIE_TD_FUNC
#include "BC_lib.h"
#endif

#if MOVIE_TD_FUNC
#include "TD_lib.h"
#endif

//#NT#2016/05/23#David Tsai -end
//#NT#2016/03/02#Lincy Lin -end
#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
//#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      //*=All
#include "DebugModule.h"



BOOL UIFlowWndMovie_OnStorageSlow_evenFlag = FALSE;
//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
extern BOOL     gb3DNROut;
#endif
//#NT#2016/09/20#Bob Huang -end

extern BOOL MCUSendAT_SOS;
extern BOOL SetCrash_Flag;

//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticICN_Protect)
CTRL_LIST_ITEM(UIFlowWndMovie_PNL_FDFrame)
#if _ADAS_FUNC_
CTRL_LIST_ITEM(UIFlowWndMovie_LDWS_Frame)
#endif
//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
CTRL_LIST_ITEM(UIFlowWndMovie_OT_DrawRect)
//#NT#2016/03/02#Lincy Lin -end
//#NT#2016/05/23#David Tsai -begin
//#NT#Support tampering detection function
CTRL_LIST_ITEM(UIFlowWndMovie_TD_DrawRect)
//#NT#2016/05/27#David Tsai -end
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnUpdateInfo(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnExeMovieTriggerRawEnc(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)

EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyNext)
//EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeySelect)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1,UIFlowWndMovie_OnCustom1)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnExeMovieTriggerRawEnc)

EVENT_ITEM(NVTEVT_UPDATE_INFO,UIFlowWndMovie_OnUpdateInfo)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK,UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW,UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME,UIFlowWndMovie_OnMovieFull) // the same handling as storage full (may need to show special message)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR,UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW,UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL,UIFlowWndMovie_OnLoopRecFull)
EVENT_ITEM(NVTEVT_CB_EMR_COMPLETED,UIFlowWndMovie_OnEMRCompleted)
EVENT_ITEM(NVTEVT_CALLBACK,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_INIT,UIFlowWndMovie_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug,UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug,UIFlowWndMovie_OnACUnplug)

EVENT_END

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_MODE|FLGKEY_UP|FLGKEY_DOWN|FLGKEY_ENTER|FLGKEY_SHUTTER2|FLGKEY_CUSTOM1|FLGKEY_MENU|FLGKEY_RIGHT)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_MODE|FLGKEY_UP|FLGKEY_DOWN|FLGKEY_ENTER|FLGKEY_SHUTTER2|FLGKEY_CUSTOM1|FLGKEY_MENU|FLGKEY_RIGHT)

//-----------------------------------------------------------------------------------------


static BOOL    g_uiRecordIngMotionDet = TRUE;
static BOOL    g_uiMovieOpenedFlag = FALSE;
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32  g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32  g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE;
BOOL g_bSpeLockFun = FALSE;
_ALIGNED(4)  GPSDATA gpsdata={0};

#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
 SDCFDIRINFO dirinfo;
 char   path[DCF_FULL_FILE_PATH_LEN];
 UINT32 uiMaxFolderID,uiPrevMaxFolderID;
 UINT32 uiStrlen;
 BOOL ret;


    uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
    // check if folder has file
    ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);
    if (ret)
    {
        while (dirinfo.uiNumOfDcfObj==0)
        {
            DCF_GetDirPath(uiMaxFolderID,path);
            uiStrlen = strlen(path);
            path[uiStrlen-1] = '\0';
            if (FileSys_DeleteDir(path) != FST_STA_OK)
            {
                debug_msg("FileSys_DeleteDir failed\r\n");
            }

            DCF_Refresh();

            uiPrevMaxFolderID = uiMaxFolderID;
            // search another Max Empty folder ID
            uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

            // break if getting max folder id is always same
            if (uiPrevMaxFolderID == uiMaxFolderID)
                break;
            // check if folder has file
            ret = DCF_GetDirInfo(uiMaxFolderID,&dirinfo);

            if (ret==FALSE)
              break;
        }
    }
}
#endif

#if USE_FILEDB
static void Filesys_dirCB(FIND_DATA *findDir, BOOL *bContinue, UINT16 *cLongname, UINT32 Param)
{
    *bContinue = TRUE;
}
#endif

INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiKeyAct;
    UINT32 uiState;
    BOOL   CheckStorageErr = FALSE;

    // flush key event first
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

    // if HDMI is inserted, DRAM size is not enough for movie recording
    if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24)
    {
        if (KeyScan_GetPlugDev() == PLUG_HDMI)
            return NVTEVT_CONSUME;
    }

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
    	if (System_GetState(SYS_STATE_CARD) == CARD_REMOVED)
        {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
        }
    }
    else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
         if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) // card lock
         {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
         }

         if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) // card insert
         {
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD,FLOWWRNMSG_TIMER_2SEC);
            return NVTEVT_CONSUME;
         }
    }

    if (paramNum>=3)
    {
        uiState = paramArray[2];
    }
    else
    {
        uiState = 0;
    }

    uiKeyAct = paramNum ? paramArray[0] : 0;

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
            //#NT#2016/09/20#Bob Huang -begin
            //#NT#Support HDMI Display with 3DNR Out
            #if (_3DNROUT_FUNC == ENABLE)
            if (MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD || gb3DNROut)
            #else
			if (1)//MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD)
            #endif
            //#NT#2016/09/20#Bob Huang -end
            {
                gMovData.State= MOV_ST_REC;
                if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
                {CHKPNT;
                    //#NT#2013/1/28#Philex Lin - begin
                    // fix bug that can't record in cyclic and card full case
                    if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
                    {
                        CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                    }
                    else
                    {
                        #if USE_FILEDB
                        if (UI_GetData(FL_IsUseFileDB))
                        {
                           if (FileSys_ScanDir("A:\\DCIM\\",Filesys_dirCB,FALSE, 0)==FST_STA_OK)
                           {
                               CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                           }
                           else
                           {
                              CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                           }
                        }
                        #else
                        CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
                        CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
                        #endif
                    }
                    if (CheckStorageErr == TRUE)
                    //#NT#2013/1/28#Philex Lin - end
                    {CHKPNT;
                        gMovData.State= MOV_ST_WARNING_MENU;
                        gMovData.SysTimeCount = 0;
                        return NVTEVT_CONSUME;
                    }
                }
                if(GetBatteryLevel() == BATTERY_EXHAUSTED)
                {
                    debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
                   // return NVTEVT_CONSUME;
                }

                if (FlowMovie_GetSelfTimerID() != NULL_TIMER)
                {
                    FlowMovie_StopRecSelfTimer();
                    return NVTEVT_CONSUME;
                }
                if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    g_uiRecordIngMotionDet = TRUE;
                else
                    g_uiRecordIngMotionDet = FALSE;

                FlowMovie_StartRec();
                // start USB detect timer again
                if (g_ACPlug == TRUE)
                    SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
                }
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            // Isiah, implement YUV merge mode of recording func.
            //if (FlowMovie_GetRecCurrTime() >= 1)
            {
                // Mask key during movie stop flow.
                Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
                Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
                FlowMovie_StopRec();
                // update ui window icon
                FlowMovie_UpdateIcons(TRUE);

                if (uiState==UIFlowWndMovie_Restart_Rec)
                {
                    // Enable key if user pressed shutter2 key to stop recording.
                    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

                    #if 1//(_KEY_METHOD_ == _KEY_METHOD_4KEY_)
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
                    #else
                    Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
                    #endif
                }
                else
                {
                    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
                    {
                        if (g_uiRecordIngMotionDet == TRUE)
                        {
                            g_uiRecordIngMotionDet = FALSE;
                            //#NT#2016/11/01#Adam Su -begin
                            //#NT#fix mantis issue 0106933
                            UI_SetData(FL_MOVIE_MOTION_DET, MOVIE_MOTIONDET_OFF);
                            //#NT#2016/11/01#Adam Su -end
                        }
                    }
                }
            }

            break;
        }
        break;
    }

    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        if (0)//((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
        {
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            return NVTEVT_PASS;
        }
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            /* set Digital Zoom interface */
            UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

            gMovData.State |= MOV_ST_ZOOM;
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    uiKeyAct = paramNum ? paramArray[0] : 0;

    debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

    switch (uiKeyAct)
    {
    case NVTEVT_KEY_PRESS:
    case NVTEVT_KEY_CONTINUE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_REC:
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
             /* set Digital Zoom interface */
             UI_SetData(FL_ZoomIFIndex,ZOOM_IF_DIGITAL);

             gMovData.State |= MOV_ST_ZOOM;
             Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
            break;
        }
        break;

    case NVTEVT_KEY_RELEASE:
        switch (gMovData.State)
        {
        case MOV_ST_VIEW | MOV_ST_ZOOM:
        case MOV_ST_REC | MOV_ST_ZOOM:
            Ux_SendEvent(&CustomPhotoObjCtrl,NVTEVT_EXE_ZOOM,2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
            gMovData.State &= ~MOV_ST_ZOOM;
            break;
        }
        break;
    }
    return NVTEVT_PASS;
}

#if MOVIE_FD_FUNC_
static void UIFlowWndMovie_ClrFDRect(void)
{
    UINT32 i;
    DISPLAYER_PARAM   DispLyr = {0} ;
    PDISP_OBJ         pDispObj = NULL;

    pDispObj = disp_getDisplayObject(DISP_1);
    //#NT#2016/03/02#Lincy Lin -begin
    //#NT#Support object tracking function
    for (i=0;i<MAX_FDNUM;i++)
    //#NT#2016/03/02#Lincy Lin -end
    {
        DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
        DispLyr.SEL.SET_FDEN.bEn = FALSE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    pDispObj->load(TRUE);
}
#endif

//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
#if MOVIE_OT_FUNC
static void UIFlowWndMovie_ClrOTRect(void)
{
    DISPLAYER_PARAM   DispLyr = {0} ;
    PDISP_OBJ         pDispObj = NULL;

    pDispObj = disp_getDisplayObject(DISP_1);
    DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM15;
    DispLyr.SEL.SET_FDEN.bEn = FALSE;
    pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    pDispObj->load(TRUE);
}
#endif
//#NT#2016/03/02#Lincy Lin -end

void UIFlowWndMovie_Initparam(void)
{
    // The same effect as Photo mode
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

    // The other settings
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);

    /* Video resolution setting must be set after other IQ settings */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,           1,  SysGetFlag(FL_MOVIE_SIZE));

    /* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_RATE_SET,          1,  SysGetFlag(FL_MOVIE_RATE));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO_VOL,         1,  SysGetFlag(FL_MOVIE_AUDIO_VOL));
    Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,                  1,  SysGetFlag(FL_EV));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_WDR,           1,  SysGetFlag(FL_MOVIE_WDR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_GSENSOR));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_SENSOR_ROTATE, 1,  SysGetFlag(FL_MOVIE_SENSOR_ROTATE));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_IR_CUT,        1,  SysGetFlag(FL_MOVIE_IR_CUT));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_AUTO,  1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_MANUAL,1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_LDWS,          1,  SysGetFlag(FL_MOVIE_LDWS));
    Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_FCW,           1,  SysGetFlag(FL_MOVIE_FCW));
    Ux_SendEvent(&UISetupObjCtrl,       NVTEVT_EXE_FREQ,                1,  SysGetFlag(FL_FREQUENCY));

}

static BOOL g_bDelayUpdateIcon = FALSE;
extern BOOL bReOpenMovie;

void UI_UpdataTimefromSDCard(void)
{
	FST_FILE  filehdl;
	UINT8 pBuf[20];
	UINT32 size = 0x20000;
	UINT32    uHour,uMinute,uSecond,uYear,uMonth,uDay;
        filehdl = FileSys_OpenFile("A:\\TIMESET.txt",FST_OPEN_READ);
	  if(filehdl != NULL)
	  {
	  	 FileSys_ReadFile(filehdl, (UINT8 *)pBuf, &size, 0, NULL);
       	 FileSys_CloseFile(filehdl);
		 debug_msg("read from SD : %s \r\n",pBuf);
		 if((pBuf[4] == '/')&&(pBuf[7] == '/')&&(pBuf[10] == ' ')&&(pBuf[13] == ':')&&(pBuf[16] == ':'))
		 {
		 	if((pBuf[0] >= '0' && pBuf[0] <= '9')&&(pBuf[1] >= '0' && pBuf[1] <= '9')&&(pBuf[2] >= '0' && pBuf[2] <= '9')&&(pBuf[3] >= '0' && pBuf[3] <= '9'))
		 	{
		 		if((pBuf[5] >= '0' && pBuf[5] <= '9')&&(pBuf[6] >= '0' && pBuf[6] <= '9')&&(pBuf[8] >= '0' && pBuf[8] <= '9')&&(pBuf[9] >= '0' && pBuf[9] <= '9'))
			 	{
			 		if((pBuf[11] >= '0' && pBuf[11] <= '9')&&(pBuf[12] >= '0' && pBuf[12] <= '9')\
						&&(pBuf[14] >= '0' && pBuf[14] <= '9')&&(pBuf[15] >= '0' && pBuf[15] <= '9')\
						&&(pBuf[17] >= '0' && pBuf[17] <= '9')&&(pBuf[18] >= '0' && pBuf[18] <= '9'))
				 	{
				 		uYear = (pBuf[3]-'0') + (pBuf[2]-'0')*10 + (pBuf[1]-'0')*100 + (pBuf[0]-'0')*1000;
						uMonth = (pBuf[6]-'0') + (pBuf[5]-'0')*10;
						uDay = (pBuf[9]-'0') + (pBuf[8]-'0')*10;
						uHour = (pBuf[12]-'0') + (pBuf[11]-'0')*10;
						uMinute =  (pBuf[15]-'0') + (pBuf[14]-'0')*10;
						uSecond =  (pBuf[18]-'0') + (pBuf[17]-'0')*10;
						if(uMonth <= 12 && uDay <= 31 && uHour <= 23 && uMinute <= 59 && uSecond <= 59)
						{
						 	rtc_setDate(uYear, uMonth, uDay);
		  					rtc_setTime(uHour, uMinute, uSecond);
		 	 				rtc_triggerCSET();
							FileSys_DeleteFile("A:\\TIMESET.txt");
							return;
						}
				 	}
			 	}
		 	}

		 }
		else
		{
			debug_msg("Time Format Error\r\n");
		}
	  }
	  else
	  {
	  	debug_msg("NO time updata file\r\n");
	  }	
	  return;
}



INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	static BOOL UpdataTimefromSDCard = TRUE;
    Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
    /* Init window key mask variables & set key and key released mask */
    g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
    g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);

    #if (GSENSOR_FUNCTION == ENABLE)
    if(UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_640x480P240
        && UI_GetData(FL_GSENSOR) != GSENSOR_OFF)
    {
        UI_SetData(FL_GSENSOR,GSENSOR_OFF);
        DBG_ERR("G-Sensor is not support on fps=240, because i2c is too busy.\r\n");
    }
    //MUST open before UIFlowWndMovie_Initparam, because Initparam call GSensor_SetSensitivity.
    GSensor_open();
    #endif

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        #if USE_FILEDB
        if (UI_GetData(FL_IsUseFileDB))
        {
           Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FILEID_RESET,0);
        }
        #endif
    }
    UIFlowWndMovie_Initparam();

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
        if(UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
			if (System_GetState(SYS_STATE_CARD)  == CARD_REMOVED) 
			{
				Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			} 
			else if(FileSys_GetDiskInfo(FST_INFO_CLUSTER_SIZE) == 0x0000)
			{
				Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_NOTFAT32, FLOWWRNMSG_TIMER_KEEP);
			}
			else
			{
           		    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR, FLOWWRNMSG_TIMER_KEEP);
        	       }
        }
    }
    //SD updata time
    if(UpdataTimefromSDCard == TRUE)
    {
    	  UpdataTimefromSDCard = FALSE;
	  UI_UpdataTimefromSDCard();	  
    }

    // update g_uiRecordIngMotionDet flag
    if (gUIMotionDetTimerID == NULL_TIMER)
    {
        gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
    }

    if (g_uiDateTimerID == NULL_TIMER)
    {
        g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
    }

    // Enable Motion Detect function in starting up movie mode
    if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
        g_uiRecordIngMotionDet = TRUE;
    else
        g_uiRecordIngMotionDet = FALSE;

    // delete empty folder
    #if (USE_FILEDB==DISABLE)
    UIFlowWndMovie_DeleteEmptyFolder();
    #endif

   UxCtrl_SetShow(&UIFlowWndMovie_StaticICN_ProtectCtrl, FALSE);
    Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);

#if ((POWERON_FAST_WIFI != ENABLE) && (POWERON_FAST_RECORD == ENABLE))
    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL)
    {
        // fast record
        UINT32 paramArray[1] = {NVTEVT_KEY_PRESS};
        UIFlowWndMovie_OnExeRecord(pCtrl, 1, paramArray);
    }

    if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
    {
    FlowMovie_UpdateIcons(TRUE);
    }
    else
    {
    FlowMovie_UpdateIcons(FALSE);
    UI_SetDisplayFlip(FALSE);
    g_bDelayUpdateIcon = TRUE;
    }
#else
    FlowMovie_UpdateIcons(TRUE);
#endif

   debug_msg("Movie open end_debug\r\n");
//yxf_debug
    //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
   // FlowMovie_StartRec();
   if(bReOpenMovie)
   {
   	bReOpenMovie = FALSE;
   }
   else
   {
   	   g_uiMovieOpenedFlag = TRUE;
   }
   MCUSendAT_SOS = FALSE;
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    #if MOVIE_FD_FUNC_
    UIFlowWndMovie_ClrFDRect();
    #endif
    //#NT#2016/03/02#Lincy Lin -begin
    //#NT#Support object tracking function
    #if MOVIE_OT_FUNC
    UIFlowWndMovie_ClrOTRect();
    #endif
    //#NT#2016/03/02#Lincy Lin -end

    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (FlowMovie_GetRecCurrTime() <= 1)
        {
            Delay_DelayMs(1000);
        }
        FlowMovie_StopRec();
        Ux_SendEvent(&UIFlowWndMovieCtrl,NVTEVT_CB_MOVIE_FINISH,0);
        break;
    }

    g_bRedLEDOn = FALSE;
    //KeyScan_TurnOffLED(KEYSCAN_LED_RED);

    if (gUIMotionDetTimerID!=NULL_TIMER)
    {
        GxTimer_StopTimer(&gUIMotionDetTimerID);
    }

    if (g_uiDateTimerID != NULL_TIMER)
    {
        GxTimer_StopTimer(&g_uiDateTimerID);
    }

    #if (GSENSOR_FUNCTION == ENABLE)
    //GSensor_close();//yxf_debug 20191128
    #endif

    Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
static void UIFlowWndMovie_OnFdEnd(void)
{
//#NT#2015/07/20#KS Hung -begin
//#NT#If enabling the ADAS, disabling Face Detection.
#if (_ADAS_FUNC_ == DISABLE)
    //if (SysGetFlag(FL_FD) != FD_OFF)
    {
        //if ((gPhotoData.State!=PHOTO_ST_CAPTURE)&&(gPhotoData.QuickViewCount==0))
        {
            /* Enable FD frame show */
            UxCtrl_SetShow(&UIFlowWndMovie_PNL_FDFrameCtrl,TRUE);

            /* Redraw all window OSD */
            UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
        }
    }
#endif
//#NT#2015/07/20#KS Hung -end
}

//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
#if MOVIE_OT_FUNC
static void UIFlowWndMovie_OnOTEnd(void)
{
    UxCtrl_SetShow(&UIFlowWndMovie_OT_DrawRectCtrl,TRUE);
    /* Redraw all window OSD */
    //UxCtrl_SetDirty(&UIFlowWndMovie_OT_DrawRectCtrl, TRUE);
}
#endif
//#NT#2016/03/02#Lincy Lin -end

//#NT#2016/05/25#David Tsai -begin
//#NT#Support tampering detection function
#if MOVIE_TD_FUNC
static void UIFlowWndMovie_OnTDEnd(void)
{
    UxCtrl_SetShow(&UIFlowWndMovie_TD_DrawRectCtrl,TRUE);
    /* Redraw all window OSD */
    //UxCtrl_SetDirty(&UIFlowWndMovie_TD_DrawRectCtrl, TRUE);
}
#endif
//#NT#2016/05/25#David Tsai -end

INT32 UIFlowWndMovie_OnUpdateInfo(VControl * pCtrl, UINT32 paramNum, UINT32 * paramArray)
{
    if (paramNum == 0)
        return NVTEVT_CONSUME;
    switch (paramArray[0])
    {
        case UIAPPPHOTO_CB_FDEND:
            UIFlowWndMovie_OnFdEnd();
            break;
        //#NT#2016/03/02#Lincy Lin -begin
        //#NT#Support object tracking function
        #if MOVIE_OT_FUNC
        case UIAPPPHOTO_CB_OTEND:
            UIFlowWndMovie_OnOTEnd();
            break;
        #endif
        //#NT#2016/03/02#Lincy Lin -end
        //#NT#2016/05/26#David Tsai -begin
        //#NT#Support tampering detection function
        #if MOVIE_TD_FUNC
        case UIAPPPHOTO_CB_TDEND:
            UIFlowWndMovie_OnTDEnd();
            break;
        #endif
        //#NT#2016/05/26#David Tsai -end
        default:
            DBG_ERR("Unknown CB %d\r\n",paramArray[0]);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // next key
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;
    //UINT32  uiWidth  = GetMovieSizeWidth(UI_GetData(FL_MOVIE_SIZE));

    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        switch(gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            // stope timer when entering menu
            if (gUIMotionDetTimerID!=NULL_TIMER)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
            }

            if (g_uiDateTimerID != NULL_TIMER)
            {
                GxTimer_StopTimer(&g_uiDateTimerID);
            }

            // Enable shutter2 sound (Select key as OK key in menu)
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask |= FLGKEY_ENTER;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);
            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gMovData.State = MOV_ST_MENU;
            break;
        case MOV_ST_REC:
        case MOV_ST_REC|MOV_ST_ZOOM:
            if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL)==MOVIE_URGENT_PROTECT_MANUAL_ON)
            {

#if (MOVIE_MULTI_RECORD_FUNC)
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
					ImageApp_MovieMulti_TrigEMR(_CFG_REC_ID_1);
				} else {
					UINT32 i, mask, movie_rec_mask;

 					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
				}
#else
				ImageApp_Movie_SetParam(_CFG_REC_ID_1, MOVIE_PARAM_FILE_TRIGEMR, 1);
#endif
				Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
				return NVTEVT_CONSUME;
			}
			break;
		}
		break;
	}

	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;

    // Similar to Shutter2 key
    uiKeyAct = paramArray[0];
    switch(uiKeyAct)
    {
        case NVTEVT_KEY_PRESS:
        {
            /*
            if (gMovData.State==MOV_ST_VIEW)
            {
                gMovData.State=MOV_ST_REC;

            }
            else if (gMovData.State==MOV_ST_REC)
            {
                gMovData.State=MOV_ST_VIEW;
                // update ui window icon
                FlowMovie_UpdateIcons(TRUE);
            }
            */
            UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
        }
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiKeyAct;
    UINT32  uiSoundMask;

    uiKeyAct = paramArray[0];

    switch (uiKeyAct)
    {
      case NVTEVT_KEY_PRESS:
        switch(gMovData.State)
        {
        case MOV_ST_VIEW:
        case MOV_ST_VIEW|MOV_ST_ZOOM:
            // stope timer when entering menu
            if (gUIMotionDetTimerID!=NULL_TIMER)
            {
                GxTimer_StopTimer(&gUIMotionDetTimerID);
            }

            if (g_uiDateTimerID != NULL_TIMER)
            {
                GxTimer_StopTimer(&g_uiDateTimerID);
            }
            // enable shutter2 sound (shutter2 as OK key in menu)
            uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
            uiSoundMask |= FLGKEY_ENTER;
            Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

            Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
            // Open common mix (Item + Option) menu
            Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
            gMovData.State = MOV_ST_MENU;
            break;
        }
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_KEY_MENU,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
//INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
//{
//    return NVTEVT_CONSUME;
    //return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
//}
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;//UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);
}

INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiSoundMask;

    switch (gMovData.State)
    {
    case MOV_ST_WARNING_MENU:
         if(paramNum > 0)
            {
                if(paramArray[0] == NVTRET_ENTER_MENU)
                {
                    /* Create Menu window */
                    gMovData.State = MOV_ST_MENU;
                    Ux_OpenWindow(&MenuCommonItemCtrl, 0);
                    return NVTEVT_CONSUME;
                }
            }
		 CHKPNT;
            gMovData.State = MOV_ST_VIEW;
        break;

    case MOV_ST_MENU:
        // disable shutter2 sound
        uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
        uiSoundMask &= ~FLGKEY_ENTER;
        Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

         g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
         g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
         Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
         Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
         FlowMovie_UpdateIcons(TRUE);

         // start timer again when exiting menu
         if (gUIMotionDetTimerID==NULL_TIMER)
         {
           gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
         }

         if (g_uiDateTimerID == NULL_TIMER)
         {
           g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
         }

         // Enable Motion Detect function in starting up movie mode
         if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON)
            g_uiRecordIngMotionDet = TRUE;
         else
            g_uiRecordIngMotionDet = FALSE;
CHKPNT;
         gMovData.State = MOV_ST_VIEW;
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeRecord(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomIn(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnExeZoomOut(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;//UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
}



//lÂ¼ÏñÖÐÅÄÕÕ
INT32 UIFlowWndMovie_OnExeMovieTriggerRawEnc(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
CHKPNT;
    UINT32 result = 0;
    //UINT32 curStatus = 0;
    UINT32 uiJpegWidth, uiJpegHeight, uiDAR, uiMovieSize;

    if (System_GetState(SYS_STATE_CURRMODE) != PRIMARY_MODE_MOVIE)
    {
        return NVTEVT_CONSUME;
    }
    //curStatus = UIFlowWndWiFiMovie_GetStatus();
   // if(MovRec_IsRecording())//curStatus == WIFI_MOV_ST_RECORD)
    if(gMovData.State == MOV_ST_REC)
    {
        uiMovieSize = UI_GetData(FL_MOVIE_SIZE);
        uiJpegWidth = GetMovieSizeWidth(uiMovieSize);
        uiJpegHeight = GetMovieSizeHeight(uiMovieSize);
        uiDAR = GetMovieDispAspectRatio(uiMovieSize);
        /*
        if (uiDAR == VIDENC_DAR_16_9)
        {
            uiJpegWidth = (uiJpegHeight * 16) / 9;
        }
        */
        Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 2, uiJpegWidth, uiJpegHeight);
    }
    else
    {
        result = -1;
        debug_msg("Not in recording state\r\n");
    }
    return NVTEVT_CONSUME;	
}

INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);

        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_FORCETO_PLAYBACK_MODE,0);
        break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
 static volatile BOOL bBatteryOn = FALSE;

    UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl,STATE_CURITEM,GetBatteryLevel());
    if (KeyScan_IsACIn())
    {
        bBatteryOn = !bBatteryOn;
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,bBatteryOn);
    } else {
        UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl,TRUE);
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Don't stop movie recording
    switch(gMovData.State)
    {
      case MOV_ST_VIEW:
      case MOV_ST_VIEW|MOV_ST_ZOOM:
        // mask key while changing primary mode
        Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
        Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
        Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
        // changing primary mode
        Ux_SendEvent(&UISetupObjCtrl,NVTEVT_EXE_CHANGEDSCMODE,1,DSCMODE_CHGTO_NEXT);
        break;

    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiFolderId=0, uiFileId=0;
    BOOL    CheckStorageErr;
    //UINT32  gUIAviRecMaxTime;

    switch (gMovData.State)
    {
      case MOV_ST_REC:
      case MOV_ST_REC|MOV_ST_ZOOM:
            #if 0
            if(UIStorageCheck(STORAGE_CHECK_FULL, &(gUIAviRecMaxTime)) != TRUE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);
            }
            #endif

            //#NT#2016/09/20#Bob Huang -begin
            //#NT#Support HDMI Display with 3DNR Out
            //call stop rec first before starting to rec, keep rec mode
            #if (_3DNROUT_FUNC == ENABLE)
            if(!gb3DNROut)
            #endif
            //#NT#2016/09/20#Bob Huang -end
            {
                CHKPNT;
                gMovData.State = MOV_ST_VIEW;
            }

            //#NT#2012/10/23#Philex Lin - begin
            // enable auto power off/USB detect timer
            KeyScan_EnableMisc(TRUE);
            //#NT#2012/10/23#Philex Lin - end
            FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            UxCtrl_SetShow(&UIFlowWndMovie_PanelCtrl,FALSE);

            //if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
            if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF)
            {
                CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
            }
            else
            {
                CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
            }
            if (CheckStorageErr == FALSE)
            {
                DCF_GetNextID(&uiFolderId, &uiFileId);
                SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
                SysSetFlag(FL_DCF_FILE_ID, uiFileId);

                FlowMovie_UpdateIcons(TRUE);
                Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            }
            break;

        //The flow here may be only for APC3 stop record than lock file function.
        //To be careful that gMovData have changed in UIFlowMovie_Stop.
        case MOV_ST_VIEW:
            #if (0)//(PRJ == APC3)
            if (paramNum)
            {
                if (paramArray[0]==UIFlowWndMovie_Restart_Rec)
                {
                    Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
                }
            }
            #endif
            // Enable key if user pressed shutter2 key to stop recording.
            Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
            break;
    }

    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (gMovData.State)
    {
    case MOV_ST_REC:
    case MOV_ST_REC|MOV_ST_ZOOM:
        if (paramNum)
        {
            UxCtrl_SetShow(&UIFlowWndMovie_PanelCtrl,!UxCtrl_IsShow(&UIFlowWndMovie_PanelCtrl));
            FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
            FlowMovie_SetRecCurrTime(paramArray[0]);
            FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
        }
//        FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
        if (UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl))
            FlowMovie_DrawPIM(FALSE);

        // For PM Demo, snap shot per one second.
        #if(_PM_DEMO_)
        if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_1080P60_D1P30)
            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0, 0, 0);
        #endif
        break;
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_OnLoopRecFull(pCtrl,paramNum,paramArray);
}
INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    if ((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM)))
    {
        FlowMovie_StopRec();
        if (System_GetState(SYS_STATE_CARD) == CARD_LOCKED)
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED,FLOWWRNMSG_TIMER_3SEC);
            //#NT#2017/05/18#Adam Su -begin
            //#NT#fix mantis bug id:0119086
            FlowMovie_UpdateIcons(TRUE);
            //#NT#2017/05/18#Adam Su -end
            return NVTEVT_CONSUME;
        }
        else
        {
            gMovData.State=MOV_ST_WARNING_MENU;
            Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR,FLOWWRNMSG_TIMER_3SEC);
            //#NT#2017/05/18#Adam Su -begin
            //#NT#fix mantis bug id:0119086
            FlowMovie_UpdateIcons(TRUE);
            //#NT#2017/05/18#Adam Su -end
            return NVTEVT_CONSUME;
        }
    }
    else
    {
        Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
    }
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // trigger re-start encoding
//#NT#2016/03/23#Isiah Chang -begin
//#NT#Do not turn off power-off protection func.
    //Movie_SetSDSlow(TRUE);
//#NT#2016/03/23#Isiah Chang -end
CHKPNT;
    UIFlowWndMovie_OnStorageSlow_evenFlag = TRUE;
    Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_StopRec();
    KeyScan_EnableMisc(TRUE);
    //gMovData.State = MOV_ST_VIEW;
    gMovData.State= MOV_ST_WARNING_MENU;
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl,2,UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL,FLOWWRNMSG_TIMER_2SEC);
    FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiPathId = 0;

    if (paramNum)
        uiPathId = paramArray[0];

    DBG_IND("EMR(%d) completed!\r\n", uiPathId);
    return NVTEVT_CONSUME;
}
#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    ide_enable_video(IDE_VIDEOID_1);
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if (CALIBRATION_FUNC == ENABLE)
    {
        // check if enter engineer mode
        if (EngineerMode_CheckEng())
        {
            Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MAIN);
            EngineerMode_Open();
        }
    }
    #endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_IconDrawDZoom(&UIFlowWndMovie_Zoom_StaticCtrl);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 uiEvent;
    if (paramNum>0)
    {
        uiEvent = paramArray[0];
        if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE)
            return NVTEVT_CONSUME;
    } else {
        return NVTEVT_CONSUME;
    }
    switch (gMovData.State)
    {
    case MOV_ST_VIEW:
        FlowMovie_UpdateIcons(TRUE);
        break;
    }
    g_PreviewStable = TRUE;

    return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowMovie_UpdateIcons(TRUE);

    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
    Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);
    return NVTEVT_CONSUME;
}
#if (GPS_FUNCTION == ENABLE)
inline static void  UIFlowWndMovie_UpdateSpeedData(void)
{
  RMCINFO RMCInfo;

      GPSRec_GetRMCDate(&RMCInfo);
      memcpy(&(gpsdata.rmcinfo),&RMCInfo,sizeof(RMCINFO));
      #if 0
      debug_msg("lati:%1f, NS:%c, longi:%1f,EW:%c\r\n",gpsdata.rmcinfo.Latitude,gpsdata.rmcinfo.NSInd,gpsdata.rmcinfo.Longitude,gpsdata.rmcinfo.EWInd);
      #endif
}
#endif

static void UIFlowWndMovie_OnMotionDetect(void)
{
    static UINT32  uiMotionDetGo = 0;
    static UINT32  uiMotionDetStop = 0;

    //#NT#2016/11/01#Adam Su -begin
    //#NT#fix mantis issue 0106933
    static BOOL    bMotionDetRec = FALSE; // TRUE: trigger record by MD
    //#NT#2016/11/01#Adam Su -end

    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#move code to support sensor map
    static UINT32  uiMotionDetRet = 0;
    Ux_SendEvent(0, NVTEVT_EXE_MOTION_DET_RUN, 1, (UINT32)&uiMotionDetRet);
    if (uiMotionDetRet==TRUE)
    //#NT#2016/10/18#Jeah Yen -end
    {
         uiMotionDetGo++;
         if (uiMotionDetGo>=2)
         {
            uiMotionDetStop=0;
            // Recording of modtion detection in pure CarDV path
            if (!((gMovData.State == MOV_ST_REC)||(gMovData.State == (MOV_ST_REC|MOV_ST_ZOOM))))
            {
                // reset uiMotionDetGo
                uiMotionDetGo = 0;
                //#NT#2016/11/01#Adam Su -begin
                //#NT#fix mantis issue 0106933
                bMotionDetRec = TRUE;
                //#NT#2016/11/01#Adam Su -end
                // press key to record video
                Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
            }
         }
    }
    else
    {
        //#NT#2016/11/01#Adam Su -begin
        //#NT#fix mantis issue 0106933
        if (bMotionDetRec == TRUE)
        {
            uiMotionDetStop++;
            if (uiMotionDetStop>=2) // 1 sec
            {
                uiMotionDetGo=0;
            }
            if (uiMotionDetStop>=20) // 10 Sec
            {
                uiMotionDetStop = 0;
                if (FlowMovie_GetRecCurrTime() >= 1)
                {
                    // CardDV path
                    if (gMovData.State==MOV_ST_REC||gMovData.State==(MOV_ST_REC|MOV_ST_ZOOM))
                    {
                        FlowMovie_StopRec();
                        bMotionDetRec = FALSE;
                    }
                }
            }
        }
        //#NT#2016/11/01#Adam Su -end
    }
}
#include "gpio.h"

INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32  uiEvent;

    uiEvent = paramNum ? paramArray[0] : 0;
    switch(uiEvent)
    {
    case NVTEVT_05SEC_TIMER:
        #if(AUTO_WIFI==ENABLE)
        {
            static BOOL autoWifi = FALSE;

            if(!autoWifi)
            {
                //#NT#2016/03/23#Isiah Chang -begin
                //#NT#add new Wi-Fi UI flow.
                #if(WIFI_UI_FLOW_VER == WIFI_UI_VER_1_0)
                Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
                #endif
                //#NT#2016/03/23#Isiah Chang -end
                BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
                autoWifi = TRUE;
            }
        }
        #endif


	
        //get GPS/GSensor Data
        //#NT#2013/3/20#Philex Lin-begin
        #if (GPS_FUNCTION == ENABLE)
        UIFlowWndMovie_UpdateSpeedData();
        #endif
        //#NT#2013/3/20#Philex Lin-end

        // Do Motion detect process
        if(g_uiRecordIngMotionDet == TRUE)
           UIFlowWndMovie_OnMotionDetect();
        break;

    case NVTEVT_1SEC_TIMER:
        if(g_bDelayUpdateIcon)
        {
            FlowMovie_UpdateIcons(TRUE);
            g_bDelayUpdateIcon = FALSE;
        }
	 if(g_uiMovieOpenedFlag == TRUE)
 	{CHKPNT;
 		 g_uiMovieOpenedFlag = FALSE;
		 Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS); 
 	}

        FlowMovie_OnTimer1SecIndex();
        // Isiah, implement YUV merge mode of recording func.
        if(MovRec_IsRecording())
        {
            Ux_SendEvent(&CustomMovieObjCtrl,NVTEVT_EXE_MOVIE_REC_STEP,0);
        }
#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
        if(System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE)
        {
        if(!MovRec_IsRecording())
        {
            if (g_PreviewStable_Record == FALSE)
            {
                if ((g_ACPlug==TRUE)&&(g_PreviewStable == TRUE))
                //if (g_PreviewStable == TRUE)
                {
                   g_PreviewStable_Record = TRUE;
                  // Ux_PostEvent(NVTEVT_KEY_SHUTTER2 , 1, NVTEVT_KEY_PRESS);
                  
                }
            }
        }
        }
#endif
        break;
    }
    Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
    g_ACPlug = TRUE;
    // start record if receiving preview stable event
    if ((g_PreviewStable == TRUE)&&(g_PreviewStable_Record == FALSE))
    {
        g_PreviewStable_Record = TRUE;
        if(UI_GetData(FL_WIFI_AUTO_RECORDING) == WIFI_AUTO_RECORDING_ON)
        {
            //Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
        }
    }
#endif
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    g_ACPlug = FALSE;
    //Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
    return NVTEVT_CONSUME;
}


INT32 UIFlowWndMovie_OnCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

	UINT32 CrashTime = 20;
	UINT32 mask,movie_rec_mask;
#if 0
    UINT32  uiWidth  = GetMovieSizeWidth(UI_GetData(FL_MOVIE_SIZE));

    if(SysGetFlag(FL_GSENSOR) !=GSENSOR_OFF)
    {
        if ( (gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT) )
        {
            if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO)==MOVIE_URGENT_PROTECT_AUTO_ON)
            {
#if (MOVIE_MULTI_RECORD_FUNC)
                if(GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE))==MOVIE_REC_TYPE_DUAL
                    || GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE))==MOVIE_REC_TYPE_CLONE)
                {
                   debug_err(("dual record, not support urgent protect !\r\n"));
                   return NVTEVT_CONSUME;
                }
#endif
                if ((uiWidth <= 1920) && (UI_GetData(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF))
                {
                    DBG_DUMP("process flash video record!!!\r\n");
                    MovRec_StopFlash(0);
                }
                else
                {
                    DBG_DUMP("Set Crash!!!\r\n");
			debug_msg("Set Crash-yxf_debug\r\n");		
                    MovRec_SetCrash();
                }
            }

        }
    }
	#endif
	#if 1
	if(paramArray[0]==NVTEVT_KEY_PRESS)
    	{
    		mask = 1;
		if (gMovData.State == MOV_ST_REC && SetCrash_Flag == TRUE) //20191129
		{


                    movie_rec_mask = Movie_GetMovieRecMask();
		       if (movie_rec_mask & mask)
		       {
				if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO) == MOVIE_URGENT_PROTECT_AUTO_ON) 
				{
					SetCrash_Flag = FALSE;//20191129
					debug_msg("Set Crash-_debug\r\n");	
					switch(SysGetFlag(FL_MOVIE_CYCLIC_REC))
					{
                       			case MOVIE_CYCLICREC_1MIN:
                          			 CrashTime = 60-1;
							   break;
						case MOVIE_CYCLICREC_3MIN:
                           				CrashTime = 60*3-1;
							   break;
						case MOVIE_CYCLICREC_5MIN:
                         				CrashTime = 60*5-1;
							   break; 	   
						case MOVIE_CYCLICREC_10MIN:
                         				CrashTime = 60*10-1;
							   break; 	 
						case MOVIE_CYCLICREC_OFF:
                         				CrashTime = 60*10-1;
							   break; 		   
					}
					UxCtrl_SetShow(&UIFlowWndMovie_StaticICN_ProtectCtrl, TRUE);
					ImageApp_MovieMulti_SetParam(_CFG_REC_ID_1,MOVIEMULTI_PARAM_FILE_ROLLBACKSEC_CRASH,CrashTime);
					ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
					MCUSendAT_SOS = FALSE;
				}
		       }
			 mask <<= 1;
		}
    	}
	#endif

	 
    return NVTEVT_CONSUME;
}
//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//---------------------UIFlowWndMovie_PanelCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel)
CTRL_LIST_END

//----------------------UIFlowWndMovie_PanelCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END


//----------------------UIFlowWndMovie_StaticICN_ProtectCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticICN_Protect)
EVENT_END

INT32 UIFlowWndMovie_PNL_Histogram_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return NVTEVT_CONSUME;
}
//---------------------UIFlowWndMovie_PNL_FDFrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_PNL_FDFrame)
CTRL_LIST_END

//----------------------UIFlowWndMovie_PNL_FDFrameCtrl Event---------------------------
INT32 UIFlowWndMovie_PNL_FDFrame_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_PNL_FDFrame)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndMovie_PNL_FDFrame_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_PNL_FDFrame_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_ADAS_FUNC_ == DISABLE)
    #if MOVIE_FD_FUNC_
    extern    URECT   gMovieFdDispCord;
    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#fix compile error
    #if (TV_FUNC == ENABLE)
    extern    DX_HANDLE gDevTVObj;
    #endif
    //#NT#2016/10/18#Jeah Yen -end
    #if VDO_USE_ROTATE_BUFFER
    extern    DX_HANDLE gDevLCDObj;
    UINT32            isLCD =0;
    #endif
    UINT32            uiRectColor = _OSD_INDEX_WHITE;
    UINT32            i,Fdnumber;
    static FD_FACE    FdInfo[MAX_FDNUM];
    PDISP_OBJ         pDispObj = NULL;
    DISPLAYER_PARAM   DispLyr = {0} ;
    URECT             DispCord = {0,0, 640,360};
    UINT32            BorderW = 3, BorderH = 3;
    ISIZE             dev1size;
    USIZE             dev1Ratio;
    UINT32            ExpandRatio=1;

    //#NT#2016/08/18#Lincy Lin -begin
    //#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL)
        return NVTEVT_CONSUME;
    //#NT#2016/08/18#Lincy Lin -end
    idec_setFDExpEn(0, 1);
    DispCord = gMovieFdDispCord;
    #if (TV_FUNC == ENABLE)
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj)
    {
        ExpandRatio = 2;
    }
    #endif
    #if VDO_USE_ROTATE_BUFFER
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj)
    {
        isLCD = 1;
    }
    #endif
    dev1size = GxVideo_GetDeviceSize(DOUT1);
    dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
    BorderW = dev1size.w/dev1Ratio.w*dev1Ratio.h*BorderH*ExpandRatio*10/dev1size.h;
    BorderW = ALIGN_ROUND(BorderW,10)/10;
    DBG_IND("[fd] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n",dev1size.w,dev1size.h,dev1Ratio.w,dev1Ratio.h,BorderW);
    DBG_IND("[fd] DispCord x=%d,y=%d, w=%d,h=%d \r\n",DispCord.x,DispCord.y,DispCord.w,DispCord.h);
    Fdnumber = FD_GetRsltFace (FdInfo,&DispCord);


    if (Fdnumber > MAX_FDNUM)
    {
        Fdnumber = MAX_FDNUM;
    }
    if (0)//SysGetFlag(FL_FD)==FD_OFF)
    {
        uiRectColor = _OSD_INDEX_TRANSPART;
    }
    else
    {
        uiRectColor = _OSD_INDEX_WHITE;
    }

    DBG_IND("[fd]FDFrame_OnDraw color=%d, \r\n",uiRectColor);

    pDispObj = disp_getDisplayObject(DISP_1);
    //#NT#2016/03/02#Lincy Lin -begin
    //#NT#Support object tracking function
    for (i=0;i<MAX_FDNUM;i++)
    //#NT#2016/03/02#Lincy Lin -end
    {
        DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
        DispLyr.SEL.SET_FDEN.bEn = FALSE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    if(uiRectColor != _OSD_INDEX_TRANSPART)
    {
        for (i=0;i<Fdnumber;i++)
        {
            // draw FD frame
            DBG_IND("[fd] %d ( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        FdInfo[i].x,
                        FdInfo[i].y,
                        FdInfo[i].w,
                        FdInfo[i].h);

            pDispObj = disp_getDisplayObject(DISP_1);
            DispLyr.SEL.SET_FDSIZE.FD_NUM = DISPFD_NUM0<<i;
            #if VDO_USE_ROTATE_BUFFER
            if(isLCD)
            {
                UINT32              in_hsz, in_vsz;
                in_hsz = dev1size.h;
                in_vsz = dev1size.w;
                DispLyr.SEL.SET_FDSIZE.uiFDX     = FdInfo[i].y;
                DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - FdInfo[i].w - FdInfo[i].x;
                DispLyr.SEL.SET_FDSIZE.uiFDW     = FdInfo[i].h;
                DispLyr.SEL.SET_FDSIZE.uiFDH     = FdInfo[i].w;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;


                DBG_IND("[fd] rotate %d( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        DispLyr.SEL.SET_FDSIZE.uiFDX,
                        DispLyr.SEL.SET_FDSIZE.uiFDY,
                        DispLyr.SEL.SET_FDSIZE.uiFDW,
                        DispLyr.SEL.SET_FDSIZE.uiFDH);
            }
            else
            #endif
            {
                DispLyr.SEL.SET_FDSIZE.uiFDX = FdInfo[i].x*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDY = FdInfo[i].y;
                DispLyr.SEL.SET_FDSIZE.uiFDW = FdInfo[i].w*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDH = FdInfo[i].h;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

            }
            DBG_IND("[fd] BorderW %d BorderH %d \r\n",DispLyr.SEL.SET_FDSIZE.uiFDBORD_W,DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

            DispLyr.SEL.SET_FDCOLOR.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
            DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

            DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDEN.bEn = TRUE;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
        }
    }
    pDispObj->load(TRUE);
    #endif
#endif

    return NVTEVT_CONSUME;
}

#if (_ADAS_FUNC_ == ENABLE)
#define AUTO_VP_TOL_HEIGHT   11
#define AUTO_VP_TOL_WIDTH    17

//extern ADAS_APPS_RESULT_INFO g_AdasResult;
#endif

//---------------------UIFlowWndMovie_LDWS_FrameCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_LDWS_Frame)
CTRL_LIST_END

//----------------------UIFlowWndMovie_LDWS_FrameCtrl Event---------------------------
INT32 UIFlowWndMovie_ADAS_DrawingLine_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_LDWS_Frame)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndMovie_ADAS_DrawingLine_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_ADAS_DrawingLine_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_ADAS_FUNC_ == ENABLE)
    ADAS_APPS_RESULT_INFO *pAdasRlt = MovieExe_GetAdasRltOSD();

    //int x1=0, y1=0, x2=0, y2=0;
    UIScreen ScreenObj = *paramArray;
    ADAS_OSD_COORDINATE *pAdasOsdCoord = NULL;

    if ((UI_GetData(FL_MOVIE_LDWS) == MOVIE_LDWS_OFF) && (UI_GetData(FL_MOVIE_FCW) == MOVIE_FCW_OFF))
        return NVTEVT_CONSUME;

    if (pAdasRlt == NULL)
    {
        return NVTEVT_CONSUME;
    }

    //debug_msg("^M%s: ScreenObj = 0x%x\r\n", __func__, ScreenObj);
    if (gMovData.State == MOV_ST_REC)
    {
        pAdasOsdCoord = (ADAS_OSD_COORDINATE *)FlowMovie_GetAdasOsdIno();

        GxGfx_SetShapeStroke(LINEBRUSH_SQUARE|LINEWEIGHT(1), FILLSTYLE_FILL);
        GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);;
#if 0
        // draw ROI region
        if (g_AdasResult.LdwsRsltInfo.Failure == LDWS_FAILURE_TRUE)
        {
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
        }
        else
        {
            GxGfx_SetShapeColor(CLRID_IDX_BLACK, CLRID_IDX_BLACK, NULL);
        }
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiROIx1, pAdasOsdCoord->uiROIy1, pAdasOsdCoord->uiROIx4, pAdasOsdCoord->uiROIy4);
#endif

        // draw lane detection result
        if (pAdasRlt->LdwsRsltInfo.Failure == LDWS_FAILURE_FALSE)
        {
            if (pAdasRlt->LdwsRsltInfo.DepartureDir == LDWS_DEPARTURE_LEFT)
            {
                GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
            }else{
                GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
            }
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiLaneLx1, pAdasOsdCoord->uiLaneLy1, pAdasOsdCoord->uiLaneLx2, pAdasOsdCoord->uiLaneLy2); // left lane

            if (pAdasRlt->LdwsRsltInfo.DepartureDir == LDWS_DEPARTURE_RIGHT)
            {
                GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
            }else{
                GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
            }
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiLaneRx1, pAdasOsdCoord->uiLaneRy1, pAdasOsdCoord->uiLaneRx2, pAdasOsdCoord->uiLaneRy2); // right lane

            //DBG_DUMP("1 Lx1 = %d, Ly1 = %d, Lx2 = %d, Ly2 = %d\r\n",pAdasOsdCoord->LaneLx1,pAdasOsdCoord->LaneLy1,pAdasOsdCoord->LaneLx2,pAdasOsdCoord->LaneLy2);
            //DBG_DUMP("1 Rx1 = %d, Ry1 = %d, Rx2 = %d, Ry2 = %d\r\n",pAdasOsdCoord->LaneRx1,pAdasOsdCoord->LaneRy1,pAdasOsdCoord->LaneRx2,pAdasOsdCoord->LaneRy2);

            // draw car location
            if (pAdasRlt->FcwsRsltInfo.FCWarning)
            {
                GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);
            }else{
                GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
            }
            GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiCarLx1, pAdasOsdCoord->uiCarLy1, pAdasOsdCoord->uiCarRx2, pAdasOsdCoord->uiCarRy2);
            //GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiCarLx1, pAdasOsdCoord->uiCarLy1, pAdasOsdCoord->uiCarRx2, pAdasOsdCoord->uiCarRy2);

        }
#if 0
        GxGfx_SetShapeColor(CLRID_IDX_MAGENTA, CLRID_IDX_GREEN, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPDefx1, pAdasOsdCoord->uiVPDefy1, pAdasOsdCoord->uiVPDefx2, pAdasOsdCoord->uiVPDefy2);
#endif

#if 1
        if (pAdasRlt->LdwsRsltInfo.Failure== LDWS_FAILURE_TRUE)
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
        else
            GxGfx_SetShapeColor(CLRID_IDX_MAGENTA, CLRID_IDX_GREEN, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPDefx1, pAdasOsdCoord->uiVPDefy1 - AUTO_VP_TOL_HEIGHT, pAdasOsdCoord->uiVPDefx2, pAdasOsdCoord->uiVPDefy2 - AUTO_VP_TOL_HEIGHT);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPDefx1, pAdasOsdCoord->uiVPDefy1 + AUTO_VP_TOL_HEIGHT, pAdasOsdCoord->uiVPDefx2, pAdasOsdCoord->uiVPDefy2 + AUTO_VP_TOL_HEIGHT);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPDefx1, pAdasOsdCoord->uiVPDefy1 - AUTO_VP_TOL_HEIGHT, pAdasOsdCoord->uiVPDefx1, pAdasOsdCoord->uiVPDefy1 + AUTO_VP_TOL_HEIGHT);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPDefx2, pAdasOsdCoord->uiVPDefy1 - AUTO_VP_TOL_HEIGHT, pAdasOsdCoord->uiVPDefx2, pAdasOsdCoord->uiVPDefy2 + AUTO_VP_TOL_HEIGHT);
#endif
        // draw new vanishing line location
        //DBG_DUMP("draw %d\r\n",g_AdasResult.LdwsRsltInfo.AutoVpParms.uiEnerUpdateMode);

        GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPNewx1, pAdasOsdCoord->uiVPNewy1, pAdasOsdCoord->uiVPNewx2, pAdasOsdCoord->uiVPNewy2);

#if 0
        // draw vanishing line location
        GxGfx_SetShapeColor(CLRID_IDX_MAGENTA, CLRID_IDX_GREEN, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->uiVPx1, pAdasOsdCoord->uiVPy1, pAdasOsdCoord->uiVPx2, pAdasOsdCoord->uiVPy2);
#endif

#if (_AUTOVP_FUNC_ == ENABLE)
        // draw vanishing line location
        GxGfx_SetShapeColor(CLRID_IDX_BLUE, CLRID_IDX_BLUE, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->AutoVPRsltX - 10, pAdasOsdCoord->AutoVPRsltY, pAdasOsdCoord->AutoVPRsltX + 10, pAdasOsdCoord->AutoVPRsltY);

#if 0
        GxGfx_SetShapeColor(CLRID_IDX_BLUE, CLRID_IDX_BLUE, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->AutoVPLinex1[0], pAdasOsdCoord->AutoVPLiney1[0], pAdasOsdCoord->AutoVPLinex2[0], pAdasOsdCoord->AutoVPLiney2[0]);
        GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->AutoVPLinex1[1], pAdasOsdCoord->AutoVPLiney1[1], pAdasOsdCoord->AutoVPLinex2[1], pAdasOsdCoord->AutoVPLiney2[1]);
        GxGfx_SetShapeColor(CLRID_IDX_GREEN, CLRID_IDX_GREEN, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->AutoVPLinex1[2], pAdasOsdCoord->AutoVPLiney1[2], pAdasOsdCoord->AutoVPLinex2[2], pAdasOsdCoord->AutoVPLiney2[2]);
        GxGfx_SetShapeColor(CLRID_IDX_YELLOW, CLRID_IDX_YELLOW, NULL);
        GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->AutoVPLinex1[3], pAdasOsdCoord->AutoVPLiney1[3], pAdasOsdCoord->AutoVPLinex2[3], pAdasOsdCoord->AutoVPLiney2[3]);
#endif
#endif

        // draw left vanishing line location
        //GxGfx_SetShapeColor(CLRID_IDX_MAGENTA, CLRID_IDX_GREEN, NULL);
        //GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->VPx1Left, pAdasOsdCoord->VPy1Left, pAdasOsdCoord->VPx2Left, pAdasOsdCoord->VPy2Left);

        // draw left vanishing line location
        //GxGfx_SetShapeColor(CLRID_IDX_MAGENTA, CLRID_IDX_GREEN, NULL);
        //GxGfx_Line(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->VPx1Right, pAdasOsdCoord->VPy1Right, pAdasOsdCoord->VPx2Right, pAdasOsdCoord->VPy2Right);

        // Draw tolerance of Auto-VP
        if (pAdasRlt->LdwsRsltInfo.DepartureDir != LDWS_DEPARTURE_NONE)
            GxGfx_SetShapeColor(CLRID_IDX_RED, CLRID_IDX_RED, NULL); // red
        else
            GxGfx_SetShapeColor(CLRID_IDX_MAGENTA, CLRID_IDX_MAGENTA, NULL);
        GxGfx_FrameRect(((DC**)ScreenObj)[GxGfx_OSD], pAdasOsdCoord->DetectRangx1, pAdasOsdCoord->DetectRangy1, pAdasOsdCoord->DetectRangx3, pAdasOsdCoord->DetectRangy3);

    }
#endif
    return NVTEVT_CONSUME;
}

//#NT#2016/03/02#Lincy Lin -begin
//#NT#Support object tracking function
//---------------------UIFlowWndMovie_OT_DrawRectCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_OT_DrawRect)
CTRL_LIST_END
//----------------------UIFlowWndMovie_OT_DrawRectCtrl Event---------------------------
INT32 UIFlowWndMovie_OT_DrawRect_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_OT_DrawRect)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndMovie_OT_DrawRect_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_OT_DrawRect_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if MOVIE_OT_FUNC

    extern    URECT   gMovieFdDispCord;
    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#fix compile error
    #if (TV_FUNC == ENABLE)
    extern    DX_HANDLE gDevTVObj;
    #endif
    //#NT#2016/10/18#Jeah Yen -end
    #if VDO_USE_ROTATE_BUFFER
    extern    DX_HANDLE gDevLCDObj;
    UINT32            isLCD =0;
    #endif
    UINT32            uiRectColor = _OSD_INDEX_WHITE;
    UINT32            OTnumber = 0;
    URECT             OTInfo;
    PDISP_OBJ         pDispObj = NULL;
    DISPLAYER_PARAM   DispLyr = {0} ;
    URECT             DispCord = {0,0, 640,360};
    UINT32            BorderW = 3, BorderH = 3;
    ISIZE             dev1size;
    USIZE             dev1Ratio;
    UINT32            ExpandRatio=1;
    UINT32            dispFdID;

    //#NT#2016/08/18#Lincy Lin -begin
    //#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL)
        return NVTEVT_CONSUME;
    //#NT#2016/08/18#Lincy Lin -end
    idec_setFDExpEn(0, 1);
    DispCord = gMovieFdDispCord;
    #if (TV_FUNC == ENABLE)
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj)
    {
        ExpandRatio = 2;
    }
    #endif
    #if VDO_USE_ROTATE_BUFFER
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj)
    {
        isLCD = 1;
    }
    #endif
    dev1size = GxVideo_GetDeviceSize(DOUT1);
    dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
    BorderW = dev1size.w/dev1Ratio.w*dev1Ratio.h*BorderH*ExpandRatio*10/dev1size.h;
    BorderW = ALIGN_ROUND(BorderW,10)/10;
    DBG_IND("[fd] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n",dev1size.w,dev1size.h,dev1Ratio.w,dev1Ratio.h,BorderW);
    DBG_IND("[fd] DispCord x=%d,y=%d, w=%d,h=%d \r\n",DispCord.x,DispCord.y,DispCord.w,DispCord.h);
    // Only when movie recording will have Object tracking
    if(MovRec_IsRecording())
    {
        OTnumber = OT_GetTarget(&OTInfo, &DispCord);
    }
    uiRectColor = _OSD_INDEX_WHITE;
    DBG_IND("[fd]FDFrame_OnDraw color=%d, \r\n",uiRectColor);
    pDispObj = disp_getDisplayObject(DISP_1);

    // use last DispFD
    dispFdID = DISPFD_NUM15;
    DispLyr.SEL.SET_FDEN.FD_NUM = dispFdID;
    DispLyr.SEL.SET_FDEN.bEn = FALSE;
    pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);


    if(OTnumber)
    {

        // draw FD frame
        DBG_IND("[ot]( %3d , %3d ; %3d , %3d )\r\n",
                    OTInfo.x,
                    OTInfo.y,
                    OTInfo.w,
                    OTInfo.h);

        #if VDO_USE_ROTATE_BUFFER
        if(isLCD)
        {
            UINT32              in_hsz, in_vsz;
            in_hsz = dev1size.h;
            in_vsz = dev1size.w;
            DispLyr.SEL.SET_FDSIZE.uiFDX     = OTInfo.y;
            DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - OTInfo.w - OTInfo.x;
            DispLyr.SEL.SET_FDSIZE.uiFDW     = OTInfo.h;
            DispLyr.SEL.SET_FDSIZE.uiFDH     = OTInfo.w;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;


            DBG_IND("[ot] rotate ( %3d , %3d ; %3d , %3d )\r\n",
                    DispLyr.SEL.SET_FDSIZE.uiFDX,
                    DispLyr.SEL.SET_FDSIZE.uiFDY,
                    DispLyr.SEL.SET_FDSIZE.uiFDW,
                    DispLyr.SEL.SET_FDSIZE.uiFDH);
        }
        else
        #endif
        {
            DispLyr.SEL.SET_FDSIZE.uiFDX = OTInfo.x*ExpandRatio;
            DispLyr.SEL.SET_FDSIZE.uiFDY = OTInfo.y;
            DispLyr.SEL.SET_FDSIZE.uiFDW = OTInfo.w*ExpandRatio;
            DispLyr.SEL.SET_FDSIZE.uiFDH = OTInfo.h;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
            DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

        }
        DBG_IND("[ot] BorderW %d BorderH %d \r\n",DispLyr.SEL.SET_FDSIZE.uiFDBORD_W,DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

        DispLyr.SEL.SET_FDCOLOR.FD_NUM = dispFdID;
        DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
        DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
        DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

        DispLyr.SEL.SET_FDEN.FD_NUM = dispFdID;
        DispLyr.SEL.SET_FDEN.bEn = TRUE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    pDispObj->load(FALSE);
    #endif
    return NVTEVT_CONSUME;
}

//#NT#2016/03/02#Lincy Lin -end

//#NT#2016/05/23#David Tsai -begin
//#NT# Support tampering detection function
//---------------------UIFlowWndMovie_TD_DrawRectCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_TD_DrawRect)
CTRL_LIST_END

//----------------------UIFlowWndMovie_TD_DrawRectCtrl Event---------------------------
INT32 UIFlowWndMovie_TD_DrawRect_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_TD_DrawRect)
EVENT_ITEM(NVTEVT_REDRAW,UIFlowWndMovie_TD_DrawRect_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_TD_DrawRect_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if MOVIE_TD_FUNC
    extern    URECT   gMovieFdDispCord;
    //#NT#2016/10/18#Jeah Yen -begin
    //#NT#fix compile error
    #if (TV_FUNC == ENABLE)
    extern    DX_HANDLE gDevTVObj;
    #endif
    //#NT#2016/10/18#Jeah Yen -end
    #if VDO_USE_ROTATE_BUFFER
    extern    DX_HANDLE gDevLCDObj;
    UINT32            isLCD =0;
    #endif
    UINT32            uiRectColor = _OSD_INDEX_WHITE;
    UINT32            i,j,Tdnumber,TdIdx,TdSize[BC_MAX_OBJ_NUM];
    static URECT      TdInfo[BC_MAX_OBJ_NUM];
    PDISP_OBJ         pDispObj = NULL;
    DISPLAYER_PARAM   DispLyr = {0} ;
    URECT             DispCord = {0,0, 640,360};
    UINT32            BorderW = 3, BorderH = 3;
    ISIZE             dev1size;
    USIZE             dev1Ratio;
    UINT32            ExpandRatio=1;

    //#NT#2016/08/18#Lincy Lin -begin
    //#NT#Fix enter sleep mode will have divide by zero exception because of GxVideo_GetDevice return NULL.
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == NULL)
        return NVTEVT_CONSUME;
    //#NT#2016/08/18#Lincy Lin -end
    idec_setFDExpEn(0, 1);
    DispCord = gMovieFdDispCord;
    #if (TV_FUNC == ENABLE)
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevTVObj)
    {
        ExpandRatio = 2;
    }
    #endif
    #if VDO_USE_ROTATE_BUFFER
    if(((DX_HANDLE)GxVideo_GetDevice(DOUT1)) == gDevLCDObj)
    {
        isLCD = 1;
    }
    #endif
    dev1size = GxVideo_GetDeviceSize(DOUT1);
    dev1Ratio = GxVideo_GetDeviceAspect(DOUT1);
    BorderW = dev1size.w/dev1Ratio.w*dev1Ratio.h*BorderH*ExpandRatio*10/dev1size.h;
    BorderW = ALIGN_ROUND(BorderW,10)/10;
    DBG_IND("[td] dev1size w=%d,h=%d dev1Ratio w=%d,h=%d, BorderW=%d\r\n",dev1size.w,dev1size.h,dev1Ratio.w,dev1Ratio.h,BorderW);
    DBG_IND("[td] DispCord x=%d,y=%d, w=%d,h=%d \r\n",DispCord.x,DispCord.y,DispCord.w,DispCord.h);
    Tdnumber = TDGetTarget(TdInfo,&DispCord);

    //if (Tdnumber > BC_MAX_OBJ_NUM)
    //{
    //    Tdnumber = BC_MAX_OBJ_NUM;
    //}
    if (Tdnumber > MAX_FDNUM)
    {
        UINT32 tmpSize;
        for (i=0;i<Tdnumber;i++)
            TdSize[i] = ((TdInfo[i].w * TdInfo[i].h) << 8) + i;

        for (i = 1; i < Tdnumber; i++)
        {
            tmpSize = TdSize[i];
            j = i - 1;
            while ((tmpSize < TdSize[j]) && (j >= 0))
            {
                TdSize[j + 1] = TdSize[j];
                j = j - 1;
            }
            TdSize[j + 1] = tmpSize;
        }
    }
    if (0)//SysGetFlag(FL_FD)==FD_OFF)
    {
        uiRectColor = _OSD_INDEX_TRANSPART;
    }
    else
    {
        if (Tdnumber > 0 && TDGetAlarm() == TRUE)
            uiRectColor = _OSD_INDEX_RED;
        else
            uiRectColor = _OSD_INDEX_WHITE;
    }

    DBG_IND("[td]TDFrame_OnDraw color=%d, \r\n",uiRectColor);

    pDispObj = disp_getDisplayObject(DISP_1);
    //for (i=0;i<BC_MAX_OBJ_NUM;i++)
    for (i=0;i<MAX_FDNUM;i++)
    {
        DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
        DispLyr.SEL.SET_FDEN.bEn = FALSE;
        pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
    }
    if(uiRectColor != _OSD_INDEX_TRANSPART)
    {
        for (i=0;i<Tdnumber;i++)
        {
            if (i >= MAX_FDNUM)
                break;

            if (Tdnumber > MAX_FDNUM)
                TdIdx = TdSize[Tdnumber-i-1] & 0xFF;
            else
                TdIdx = i;
            // draw TD frame
            DBG_IND("[td] %d ( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        TdInfo[TdIdx].x,
                        TdInfo[TdIdx].y,
                        TdInfo[TdIdx].w,
                        TdInfo[TdIdx].h);

            pDispObj = disp_getDisplayObject(DISP_1);
            DispLyr.SEL.SET_FDSIZE.FD_NUM = DISPFD_NUM0<<i;
            #if VDO_USE_ROTATE_BUFFER
            if(isLCD)
            {
                UINT32              in_hsz, in_vsz;
                in_hsz = dev1size.h;
                in_vsz = dev1size.w;
                DispLyr.SEL.SET_FDSIZE.uiFDX     = TdInfo[TdIdx].y;
                DispLyr.SEL.SET_FDSIZE.uiFDY     = in_vsz - TdInfo[TdIdx].w - TdInfo[TdIdx].x;
                DispLyr.SEL.SET_FDSIZE.uiFDW     = TdInfo[TdIdx].h;
                DispLyr.SEL.SET_FDSIZE.uiFDH     = TdInfo[TdIdx].w;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderH;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderW;


                DBG_IND("[td] rotate %d( %3d , %3d ; %3d , %3d )\r\n",
                        i,
                        DispLyr.SEL.SET_FDSIZE.uiFDX,
                        DispLyr.SEL.SET_FDSIZE.uiFDY,
                        DispLyr.SEL.SET_FDSIZE.uiFDW,
                        DispLyr.SEL.SET_FDSIZE.uiFDH);
            }
            else
            #endif
            {
                DispLyr.SEL.SET_FDSIZE.uiFDX = TdInfo[TdIdx].x*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDY = TdInfo[TdIdx].y;
                DispLyr.SEL.SET_FDSIZE.uiFDW = TdInfo[TdIdx].w*ExpandRatio;
                DispLyr.SEL.SET_FDSIZE.uiFDH = TdInfo[TdIdx].h;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_W = BorderW;
                DispLyr.SEL.SET_FDSIZE.uiFDBORD_H = BorderH;

            }
            DBG_IND("[td] BorderW %d BorderH %d \r\n",DispLyr.SEL.SET_FDSIZE.uiFDBORD_W,DispLyr.SEL.SET_FDSIZE.uiFDBORD_H);
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDSIZE, &DispLyr);

            DispLyr.SEL.SET_FDCOLOR.FD_NUM = DISPFD_NUM0<<i;
            if (uiRectColor == _OSD_INDEX_RED)
            {
                DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0x52;
                DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x5A;
                DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0xF0;
            }
            else // _OSD_INDEX_WHITE
            {
                DispLyr.SEL.SET_FDCOLOR.uiFDCRY = 0xFF;
                DispLyr.SEL.SET_FDCOLOR.uiFDCRCb = 0x80;
                DispLyr.SEL.SET_FDCOLOR.uiFDCRCr = 0x80;
            }
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDCOLOR, &DispLyr);

            DispLyr.SEL.SET_FDEN.FD_NUM = DISPFD_NUM0<<i;
            DispLyr.SEL.SET_FDEN.bEn = TRUE;
            pDispObj->dispLyrCtrl(DISPLAYER_FD, DISPLAYER_OP_SET_FDEN, &DispLyr);
        }
    }
    pDispObj->load(TRUE);
    #endif

    return NVTEVT_CONSUME;
}
//#NT#2016/05/23#David Tsai -end
